# -*- coding: utf-8 -*-
"""ì¶”ì²œì•Œê³ ë¦¬ì¦˜_ì§„ì§œìµœì¢….ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XyArmeUX-cr48VVBa2808KtVkrNq7Yd7
"""

import pandas as pd
import re

# ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
user_df = pd.read_csv('ì‚¬ìš©ì_í”„ë¡œí•„_ìˆ˜ì •ë¨.csv')
snack_df = pd.read_csv('ê³¼ì_ë°ì´í„°ì…‹.csv')
drink_df = pd.read_csv('ìŒë£Œ_ë°ì´í„°ì…‹.csv')
ramen_df = pd.read_csv('ë¼ë©´_ë°ì´í„°ì…‹.csv')

# ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ë° í†µí•©
snack_df['category'] = 'ê³¼ì'
drink_df['category'] = 'ìŒë£Œ'
ramen_df['category'] = 'ë¼ë©´'
product_df = pd.concat([snack_df, drink_df, ramen_df], ignore_index=True)

# í…ìŠ¤íŠ¸ ì •ë¦¬ í•¨ìˆ˜
def clean_text(text):
    return re.sub(r'[^ê°€-í£a-zA-Z0-9]', '', str(text).lower())

# ì í•© ì—¬ë¶€ íŒë‹¨ í•¨ìˆ˜ (ì•Œë ˆë¥´ê¸° + ì„ì‚°ë¶€ ê³ ë ¤, í”¼í•´ì•¼í•  ì„±ë¶„ ì œì™¸)
def is_product_suitable(user, product_row):
    ingredient_text = clean_text(product_row['ì›ì¬ë£Œëª…']) + ' ' + clean_text(product_row['ì˜ì–‘ì •ë³´'])

    # ì•Œë ˆë¥´ê¸° ê³ ë ¤
    allergies = [clean_text(a) for a in str(user['allergies']).split(',') if a] if pd.notna(user['allergies']) else []
    for allergy in allergies:
        if allergy and re.search(rf'{allergy}', ingredient_text):
            return False

    # ì„ì‚°ë¶€ì¼ ê²½ìš° ìœ„í—˜ ì„±ë¶„ í•„í„°ë§
    if user['is_pregnant']:
        for risky in ['ì¹´í˜ì¸', 'ì•„í™©ì‚°', 'ì•Œì½”ì˜¬']:
            if re.search(rf'{clean_text(risky)}', ingredient_text):
                return False

    return True

# ì‚¬ìš©ì IDì™€ ìƒí’ˆ í‚¤ì›Œë“œë¡œ ì í•© ì—¬ë¶€ íŒë‹¨ (ë¶€ë¶„ ê²€ìƒ‰ í¬í•¨)
def check_suitability(user_id, keyword):
    if user_id not in user_df['user_id'].values:
        return f"âŒ ì‚¬ìš©ì ID '{user_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

    matches = product_df[product_df['í’ˆëª…'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"âŒ '{keyword}' í‚¤ì›Œë“œë¥¼ í¬í•¨í•œ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤."

    user = user_df[user_df['user_id'] == user_id].iloc[0]

    results = []
    for _, product in matches.iterrows():
        suitable = is_product_suitable(user, product)
        mark = 'âœ…' if suitable else 'âŒ'
        results.append(f"{mark} '{product['í’ˆëª…']}' â†’ {'ì í•©' if suitable else 'ë¶€ì í•©'}")

    return '\n'.join(results)

# ì˜ˆì‹œ ì‹¤í–‰
print(check_suitability('U001', 'ê¹Œë¥´ë³´ë‚˜ë¼'))

# ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜ (ì²˜ìŒ 1íšŒë§Œ)
# !pip install xgboost pandas

import pandas as pd
import xgboost as xgb

# 1. ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
user_df = pd.read_csv('ì‚¬ìš©ì_í”„ë¡œí•„_ìˆ˜ì •ë¨.csv')
interaction_df = pd.read_csv('ì´ˆê¸°_ìƒí˜¸ì‘ìš©_ì‹ .csv')
snack_df = pd.read_csv('ê³¼ì_ë°ì´í„°ì…‹.csv')
drink_df = pd.read_csv('ìŒë£Œ_ë°ì´í„°ì…‹.csv')
ramen_df = pd.read_csv('ë¼ë©´_ë°ì´í„°ì…‹.csv')

# 2. ì¹´í…Œê³ ë¦¬ ë¶™ì´ê¸° + í†µí•©
snack_df['category'] = 'ê³¼ì'
drink_df['category'] = 'ìŒë£Œ'
ramen_df['category'] = 'ë¼ë©´'
product_df = pd.concat([snack_df, drink_df, ramen_df], ignore_index=True)

# 3. interactionì— ì‚¬ìš©ì + ìƒí’ˆ ì •ë³´ ë³‘í•©
import re
import xgboost as xgb

merged_df = interaction_df.merge(user_df, on='user_id', how='left')
merged_df = merged_df.merge(product_df, left_on='item_id', right_on='í’ˆëª…', how='left')

# 4. íŠ¹ì„± ì¶”ì¶œ í•¨ìˆ˜
def prepare_features_for_training(df):
    df['user_age'] = df['age']
    df['user_gender'] = df['gender'].map({'female': 1, 'male': 0})
    df['is_pregnant'] = df['is_pregnant'].astype(int)

    df['contains_ìš°ìœ '] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ìš°ìœ ').astype(int)
    df['contains_ëŒ€ë‘'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ëŒ€ë‘').astype(int)
    df['contains_ë°€'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë°€').astype(int)
    df['contains_í˜¸ë‘'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('í˜¸ë‘').astype(int)
    df['contains_ë©”ë°€'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë©”ë°€').astype(int)
    df['contains_ìƒˆìš°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ìƒˆìš°').astype(int)
    df['contains_ì¡°ê°œë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì¡°ê°œë¥˜').astype(int)
    df['contains_í† ë§ˆí† '] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('í† ë§ˆí† ').astype(int)
    df['contains_ë”¸ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë”¸ê¸°').astype(int)
    df['contains_ê²Œ'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ê²Œ').astype(int)
    df['contains_ì˜¤ì§•ì–´'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì˜¤ì§•ì–´').astype(int)
    df['contains_ê³ ë“±ì–´'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ê³ ë“±ì–´').astype(int)
    df['contains_ë‹­ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë‹­ê³ ê¸°').astype(int)
    df['contains_ì‡ ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì‡ ê³ ê¸°').astype(int)
    df['contains_ë³µìˆ­ì•„'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë³µìˆ­ì•„').astype(int)
    df['contains_ì£'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì£').astype(int)
    df['contains_ë•…ì½©'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë•…ì½©').astype(int)
    df['contains_ë¼ì§€ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë¼ì§€ê³ ê¸°').astype(int)
    df['contains_ì•„í™©ì‚°ë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì•„í™©ì‚°ë¥˜').astype(int)
    df['contains_ì•Œë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì•Œë¥˜').astype(int)
    return df[['user_age', 'user_gender', 'is_pregnant',
                   'contains_ìš°ìœ ', 'contains_ëŒ€ë‘', 'contains_ë°€', 'contains_í˜¸ë‘','contains_ë©”ë°€','contains_ìƒˆìš°','contains_ì¡°ê°œë¥˜','contains_í† ë§ˆí† ','contains_ë”¸ê¸°', 'contains_ê²Œ', 'contains_ì˜¤ì§•ì–´', 'contains_ê³ ë“±ì–´', 'contains_ë‹­ê³ ê¸°', 'contains_ì‡ ê³ ê¸°', 'contains_ë³µìˆ­ì•„','contains_ì£', 'contains_ë•…ì½©', 'contains_ë¼ì§€ê³ ê¸°', 'contains_ì•„í™©ì‚°ë¥˜','contains_ì•Œë¥˜']]

# 5. í•™ìŠµ ë°ì´í„° êµ¬ì„±
X = prepare_features_for_training(merged_df)
y = merged_df['liked']

# 6. XGBoost ëª¨ë¸ í•™ìŠµ
dtrain = xgb.DMatrix(X, label=y)
params = {
    'objective': 'binary:logistic',
    'eval_metric': 'logloss',
    'max_depth': 3,
    'eta': 0.1,
    'seed': 42
}
xgb_model = xgb.train(params, dtrain, num_boost_round=100)

# 7. ëª¨ë¸ ì €ì¥ (Colab ê²½ë¡œì— ì €ì¥ë¨)
xgb_model.save_model('xgb_model.model')
print("âœ… xgb_model.model ì €ì¥ ì™„ë£Œ!")

def prepare_features(user, products):
    df = products.copy()
    df['user_age'] = user['age']
    df['user_gender'] = 1 if user['gender'] == 'female' else 0
    df['is_pregnant'] = 1 if user['is_pregnant'] else 0

    df['contains_ìš°ìœ '] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ìš°ìœ ').astype(int)
    df['contains_ëŒ€ë‘'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ëŒ€ë‘').astype(int)
    df['contains_ë°€'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë°€').astype(int)
    df['contains_í˜¸ë‘'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('í˜¸ë‘').astype(int)
    df['contains_ë©”ë°€'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë©”ë°€').astype(int)
    df['contains_ìƒˆìš°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ìƒˆìš°').astype(int)
    df['contains_ì¡°ê°œë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì¡°ê°œë¥˜').astype(int)
    df['contains_í† ë§ˆí† '] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('í† ë§ˆí† ').astype(int)
    df['contains_ë”¸ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë”¸ê¸°').astype(int)
    df['contains_ê²Œ'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ê²Œ').astype(int)
    df['contains_ì˜¤ì§•ì–´'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì˜¤ì§•ì–´').astype(int)
    df['contains_ê³ ë“±ì–´'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ê³ ë“±ì–´').astype(int)
    df['contains_ë‹­ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë‹­ê³ ê¸°').astype(int)
    df['contains_ì‡ ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì‡ ê³ ê¸°').astype(int)
    df['contains_ë³µìˆ­ì•„'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë³µìˆ­ì•„').astype(int)
    df['contains_ì£'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì£').astype(int)
    df['contains_ë•…ì½©'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë•…ì½©').astype(int)
    df['contains_ë¼ì§€ê³ ê¸°'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ë¼ì§€ê³ ê¸°').astype(int)
    df['contains_ì•„í™©ì‚°ë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì•„í™©ì‚°ë¥˜').astype(int)
    df['contains_ì•Œë¥˜'] = df['ì›ì¬ë£Œëª…'].fillna('').str.contains('ì•Œë¥˜').astype(int)
    return df[['user_age', 'user_gender', 'is_pregnant',
                   'contains_ìš°ìœ ', 'contains_ëŒ€ë‘', 'contains_ë°€', 'contains_í˜¸ë‘','contains_ë©”ë°€','contains_ìƒˆìš°','contains_ì¡°ê°œë¥˜','contains_í† ë§ˆí† ','contains_ë”¸ê¸°', 'contains_ê²Œ', 'contains_ì˜¤ì§•ì–´', 'contains_ê³ ë“±ì–´', 'contains_ë‹­ê³ ê¸°', 'contains_ì‡ ê³ ê¸°', 'contains_ë³µìˆ­ì•„','contains_ì£', 'contains_ë•…ì½©', 'contains_ë¼ì§€ê³ ê¸°', 'contains_ì•„í™©ì‚°ë¥˜','contains_ì•Œë¥˜']]
# 4. ë©”ì¸ ì¶”ì²œ í•¨ìˆ˜
def recommend_xg(user_id, keyword, xgb_model_path='xgb_model.model', topk=5):
    # ì‚¬ìš©ì ì„ íƒ
    if user_id not in user_df['user_id'].values:
        return f"âŒ ì‚¬ìš©ì ID '{user_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    user = user_df[user_df['user_id'] == user_id].iloc[0]

    # ì…ë ¥ ìƒí’ˆ ê²€ìƒ‰
    matches = product_df[product_df['í’ˆëª…'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"âŒ '{keyword}' í‚¤ì›Œë“œë¥¼ í¬í•¨í•œ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤."
    base_product = matches.iloc[0]
    base_category = base_product['category']

    # ê°™ì€ ì¹´í…Œê³ ë¦¬ ë‚´ ìœ ì‚¬ ì œí’ˆ ì¶”ì¶œ (ì…ë ¥ ìƒí’ˆ ì œì™¸)
    candidates = product_df[(product_df['category'] == base_category) &
                            (product_df['í’ˆëª…'] != base_product['í’ˆëª…'])].copy()

    # ì í•©í•œ ì œí’ˆë§Œ í•„í„°ë§ (ì•Œë ˆë¥´ê¸° + ì„ì‹  ê³ ë ¤)
    candidates = candidates[candidates.apply(lambda row: is_product_suitable(user, row), axis=1)]

    # íŠ¹ì§• ìƒì„± + ì˜ˆì¸¡
    X = prepare_features(user, candidates)
    dmatrix = xgb.DMatrix(X)

    # ëª¨ë¸ ë¡œë“œ ë° ì˜ˆì¸¡
    booster = xgb.Booster()
    booster.load_model('xgb_model.model')
    preds = booster.predict(dmatrix)

    candidates['xgb_score'] = preds
    top_items = candidates.sort_values(by='xgb_score', ascending=False).head(topk)

    return top_items[['í’ˆëª…', 'xgb_score']]

def xgb_recommendation(result_df, user_id, topk=5, detailed=False):
    print(f"ğŸ‘¤ {user_id}ë‹˜ì´ ì„ íƒí•˜ì‹  ìƒí’ˆê³¼(ì™€) ìœ ì‚¬í•œ ì¶”ì²œ ìƒí’ˆ Top {topk}:")
    print("=" * 50)

    if isinstance(result_df, str):  # ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜ëœ ê²½ìš°
        print(result_df)
        return

    if detailed:
        for i, row in result_df.head(topk).iterrows():
            print(f"{i+1}. {row['í’ˆëª…']}")
            print(f"   - XGBoost ì ìˆ˜ : {row['xgb_score']:.4f}")
            print("-" * 40)
    else:
        for i, name in enumerate(result_df['í’ˆëª…'].head(topk), start=1):
            print(f"{i}. {name}")

# ì˜ˆì‹œ ì‹¤í–‰
result = recommend_xg('U002', 'ê°ìê¹¡', topk=5)
xgb_recommendation(result, user_id='U002', topk=5, detailed=True)   # ì ìˆ˜ í¬í•¨

xgb_recommendation(result, user_id='U002', topk=5, detailed=False)  # í’ˆëª…ë§Œ ì¶œë ¥

"""â†‘ XGBoostë¥¼ ì´ìš©í•œ ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ (ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ë°˜ì˜X)

â†“ XGBoost + LightFM
"""

!pip install lightfm
from lightfm import LightFM
from lightfm.data import Dataset
import pickle

# 1. ìƒí˜¸ì‘ìš© ë°ì´í„° ë¡œë“œ
interaction_df = pd.read_csv('ì´ˆê¸°_ìƒí˜¸ì‘ìš©_ëœë¤ë³€ê²½.csv')  # íŒŒì¼ëª…ì— ê³µë°± ìˆìŒ ì£¼ì˜

# 2. ê³ ìœ  ìœ ì €/ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸ ìˆ˜ì§‘
user_list = interaction_df['user_id'].unique().tolist()
item_list = interaction_df['item_id'].unique().tolist()

# 3. Dataset ìƒì„± ë° fit
dataset = Dataset()
dataset.fit(users=user_list, items=item_list)

# 4. ìƒí˜¸ì‘ìš© ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
(interactions, weights) = dataset.build_interactions([
    (row['user_id'], row['item_id'], row['liked']) for _, row in interaction_df.iterrows()
])

# 5. ëª¨ë¸ ì •ì˜ ë° í•™ìŠµ
model = LightFM(loss='warp')  # WARP: ì¶”ì²œì— ì í•©í•œ ìˆœìœ„ ê¸°ë°˜ ì†ì‹¤ í•¨ìˆ˜
model.fit(interactions, epochs=20, num_threads=2)

# 6. ë§¤í•‘ ì €ì¥
user_id_map, user_feature_map, item_id_map, item_feature_map = dataset.mapping()
with open('lightfm_mapping.pkl', 'wb') as f:
    pickle.dump({'user_id_map': user_id_map, 'item_id_map': item_id_map}, f)

# 7. ëª¨ë¸ ì €ì¥
with open('lightfm_model.pkl', 'wb') as f:
    pickle.dump(model, f)

print("âœ… LightFM í•™ìŠµ ì™„ë£Œ ë° ì €ì¥ ì™„ë£Œ!")

def full_recommendation(user_id, keyword, user_df, product_df, xgb_model_path, lightfm_model_path, mapping_path, topk=5, detailed=False):
    import pickle
    import numpy as np
    import xgboost as xgb

    # Load LightFM ëª¨ë¸ê³¼ ë§¤í•‘
    with open(lightfm_model_path, 'rb') as f:
        lightfm_model = pickle.load(f)
    with open(mapping_path, 'rb') as f:
        mapping = pickle.load(f)
        user_id_map = mapping['user_id_map']
        item_id_map = mapping['item_id_map']

    # ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    if user_id not in user_df['user_id'].values:
        return f"âŒ ì‚¬ìš©ì ID '{user_id}' ì—†ìŒ"
    user = user_df[user_df['user_id'] == user_id].iloc[0]

    # ì…ë ¥ í’ˆëª… ê²€ìƒ‰ â†’ ê°™ì€ ì¹´í…Œê³ ë¦¬ í›„ë³´ ì¶”ì¶œ
    matches = product_df[product_df['í’ˆëª…'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"âŒ '{keyword}' í‚¤ì›Œë“œì— í•´ë‹¹í•˜ëŠ” ìƒí’ˆ ì—†ìŒ"
    base_product = matches.iloc[0]
    base_category = base_product['category']

    candidates = product_df[(product_df['category'] == base_category) &
                            (product_df['í’ˆëª…'] != base_product['í’ˆëª…'])].copy()

    # í•„í„°ë§ (ì•Œë ˆë¥´ê¸°, ì„ì‹ )
    candidates = candidates[candidates.apply(lambda row: is_product_suitable(user, row), axis=1)]

    # XGBoost íŠ¹ì§• ìƒì„± ë° ì˜ˆì¸¡
    X = prepare_features(user, candidates)
    dmatrix = xgb.DMatrix(X)
    booster = xgb.Booster()
    booster.load_model('xgb_model.model')
    preds = booster.predict(dmatrix)
    candidates['xgb_score'] = preds

    # LightFM ì ìˆ˜ ê³„ì‚°
    user_idx = user_id_map.get(user_id)
    product_names = candidates['í’ˆëª…'].tolist()
    item_indices = [item_id_map.get(name, -1) for name in product_names]
    scores = np.zeros(len(product_names))
    valid_idx = [i for i, idx in enumerate(item_indices) if idx >= 0]

    if user_idx is not None and valid_idx:
        preds = lightfm_model.predict(user_ids=user_idx, item_ids=[item_indices[i] for i in valid_idx])
        for i, score in zip(valid_idx, preds):
            scores[i] = score

    candidates['lightfm_score'] = scores
    candidates['final_score'] = 0.5 * candidates['xgb_score'] + 0.5 * candidates['lightfm_score']
    result = candidates.sort_values(by='final_score', ascending=False).reset_index(drop=True)

        # ğŸ”½ ì¶œë ¥ ë¶„ê¸°
    print(f"ğŸ‘¤ {user_id}ë‹˜ì´ ì„ íƒí•˜ì‹  ìƒí’ˆê³¼(ì™€) ìœ ì‚¬í•œ ì¶”ì²œ ìƒí’ˆ Top {topk}:")
    print("=" * 50)
    for i, row in result.head(topk).iterrows():
        print(f"{i+1}. {row['í’ˆëª…']}")
        if detailed:
            print(f"   - XGBoost ì ìˆ˜ : {row['xgb_score']:.4f}")
            print(f"   - LightFM ì ìˆ˜ : {row['lightfm_score']:.4f}")
            print(f"   - ìµœì¢… ì¶”ì²œ ì ìˆ˜: {row['final_score']:.4f}")
            print("-" * 40)

full_recommendation("U002", "ê°ìê¹¡", user_df, product_df,'xgb_model.model', 'lightfm_model.pkl', 'lightfm_mapping.pkl', topk=5, detailed=True)

full_recommendation("U002", "ê°ìê¹¡", user_df, product_df,'xgb_model.model', 'lightfm_model.pkl', 'lightfm_mapping.pkl', topk=5, detailed = False)
