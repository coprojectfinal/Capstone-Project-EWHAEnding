# -*- coding: utf-8 -*-
"""추천알고리즘_진짜최종.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XyArmeUX-cr48VVBa2808KtVkrNq7Yd7
"""

import pandas as pd
import re

# 데이터 불러오기
user_df = pd.read_csv('사용자_프로필_수정됨.csv')
snack_df = pd.read_csv('과자_데이터셋.csv')
drink_df = pd.read_csv('음료_데이터셋.csv')
ramen_df = pd.read_csv('라면_데이터셋.csv')

# 카테고리 추가 및 통합
snack_df['category'] = '과자'
drink_df['category'] = '음료'
ramen_df['category'] = '라면'
product_df = pd.concat([snack_df, drink_df, ramen_df], ignore_index=True)

# 텍스트 정리 함수
def clean_text(text):
    return re.sub(r'[^가-힣a-zA-Z0-9]', '', str(text).lower())

# 적합 여부 판단 함수 (알레르기 + 임산부 고려, 피해야할 성분 제외)
def is_product_suitable(user, product_row):
    ingredient_text = clean_text(product_row['원재료명']) + ' ' + clean_text(product_row['영양정보'])

    # 알레르기 고려
    allergies = [clean_text(a) for a in str(user['allergies']).split(',') if a] if pd.notna(user['allergies']) else []
    for allergy in allergies:
        if allergy and re.search(rf'{allergy}', ingredient_text):
            return False

    # 임산부일 경우 위험 성분 필터링
    if user['is_pregnant']:
        for risky in ['카페인', '아황산', '알코올']:
            if re.search(rf'{clean_text(risky)}', ingredient_text):
                return False

    return True

# 사용자 ID와 상품 키워드로 적합 여부 판단 (부분 검색 포함)
def check_suitability(user_id, keyword):
    if user_id not in user_df['user_id'].values:
        return f"❌ 사용자 ID '{user_id}'를 찾을 수 없습니다."

    matches = product_df[product_df['품명'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"❌ '{keyword}' 키워드를 포함한 상품이 없습니다."

    user = user_df[user_df['user_id'] == user_id].iloc[0]

    results = []
    for _, product in matches.iterrows():
        suitable = is_product_suitable(user, product)
        mark = '✅' if suitable else '❌'
        results.append(f"{mark} '{product['품명']}' → {'적합' if suitable else '부적합'}")

    return '\n'.join(results)

# 예시 실행
print(check_suitability('U001', '까르보나라'))

# 라이브러리 설치 (처음 1회만)
# !pip install xgboost pandas

import pandas as pd
import xgboost as xgb

# 1. 데이터 불러오기
user_df = pd.read_csv('사용자_프로필_수정됨.csv')
interaction_df = pd.read_csv('초기_상호작용_신.csv')
snack_df = pd.read_csv('과자_데이터셋.csv')
drink_df = pd.read_csv('음료_데이터셋.csv')
ramen_df = pd.read_csv('라면_데이터셋.csv')

# 2. 카테고리 붙이기 + 통합
snack_df['category'] = '과자'
drink_df['category'] = '음료'
ramen_df['category'] = '라면'
product_df = pd.concat([snack_df, drink_df, ramen_df], ignore_index=True)

# 3. interaction에 사용자 + 상품 정보 병합
import re
import xgboost as xgb

merged_df = interaction_df.merge(user_df, on='user_id', how='left')
merged_df = merged_df.merge(product_df, left_on='item_id', right_on='품명', how='left')

# 4. 특성 추출 함수
def prepare_features_for_training(df):
    df['user_age'] = df['age']
    df['user_gender'] = df['gender'].map({'female': 1, 'male': 0})
    df['is_pregnant'] = df['is_pregnant'].astype(int)

    df['contains_우유'] = df['원재료명'].fillna('').str.contains('우유').astype(int)
    df['contains_대두'] = df['원재료명'].fillna('').str.contains('대두').astype(int)
    df['contains_밀'] = df['원재료명'].fillna('').str.contains('밀').astype(int)
    df['contains_호두'] = df['원재료명'].fillna('').str.contains('호두').astype(int)
    df['contains_메밀'] = df['원재료명'].fillna('').str.contains('메밀').astype(int)
    df['contains_새우'] = df['원재료명'].fillna('').str.contains('새우').astype(int)
    df['contains_조개류'] = df['원재료명'].fillna('').str.contains('조개류').astype(int)
    df['contains_토마토'] = df['원재료명'].fillna('').str.contains('토마토').astype(int)
    df['contains_딸기'] = df['원재료명'].fillna('').str.contains('딸기').astype(int)
    df['contains_게'] = df['원재료명'].fillna('').str.contains('게').astype(int)
    df['contains_오징어'] = df['원재료명'].fillna('').str.contains('오징어').astype(int)
    df['contains_고등어'] = df['원재료명'].fillna('').str.contains('고등어').astype(int)
    df['contains_닭고기'] = df['원재료명'].fillna('').str.contains('닭고기').astype(int)
    df['contains_쇠고기'] = df['원재료명'].fillna('').str.contains('쇠고기').astype(int)
    df['contains_복숭아'] = df['원재료명'].fillna('').str.contains('복숭아').astype(int)
    df['contains_잣'] = df['원재료명'].fillna('').str.contains('잣').astype(int)
    df['contains_땅콩'] = df['원재료명'].fillna('').str.contains('땅콩').astype(int)
    df['contains_돼지고기'] = df['원재료명'].fillna('').str.contains('돼지고기').astype(int)
    df['contains_아황산류'] = df['원재료명'].fillna('').str.contains('아황산류').astype(int)
    df['contains_알류'] = df['원재료명'].fillna('').str.contains('알류').astype(int)
    return df[['user_age', 'user_gender', 'is_pregnant',
                   'contains_우유', 'contains_대두', 'contains_밀', 'contains_호두','contains_메밀','contains_새우','contains_조개류','contains_토마토','contains_딸기', 'contains_게', 'contains_오징어', 'contains_고등어', 'contains_닭고기', 'contains_쇠고기', 'contains_복숭아','contains_잣', 'contains_땅콩', 'contains_돼지고기', 'contains_아황산류','contains_알류']]

# 5. 학습 데이터 구성
X = prepare_features_for_training(merged_df)
y = merged_df['liked']

# 6. XGBoost 모델 학습
dtrain = xgb.DMatrix(X, label=y)
params = {
    'objective': 'binary:logistic',
    'eval_metric': 'logloss',
    'max_depth': 3,
    'eta': 0.1,
    'seed': 42
}
xgb_model = xgb.train(params, dtrain, num_boost_round=100)

# 7. 모델 저장 (Colab 경로에 저장됨)
xgb_model.save_model('xgb_model.model')
print("✅ xgb_model.model 저장 완료!")

def prepare_features(user, products):
    df = products.copy()
    df['user_age'] = user['age']
    df['user_gender'] = 1 if user['gender'] == 'female' else 0
    df['is_pregnant'] = 1 if user['is_pregnant'] else 0

    df['contains_우유'] = df['원재료명'].fillna('').str.contains('우유').astype(int)
    df['contains_대두'] = df['원재료명'].fillna('').str.contains('대두').astype(int)
    df['contains_밀'] = df['원재료명'].fillna('').str.contains('밀').astype(int)
    df['contains_호두'] = df['원재료명'].fillna('').str.contains('호두').astype(int)
    df['contains_메밀'] = df['원재료명'].fillna('').str.contains('메밀').astype(int)
    df['contains_새우'] = df['원재료명'].fillna('').str.contains('새우').astype(int)
    df['contains_조개류'] = df['원재료명'].fillna('').str.contains('조개류').astype(int)
    df['contains_토마토'] = df['원재료명'].fillna('').str.contains('토마토').astype(int)
    df['contains_딸기'] = df['원재료명'].fillna('').str.contains('딸기').astype(int)
    df['contains_게'] = df['원재료명'].fillna('').str.contains('게').astype(int)
    df['contains_오징어'] = df['원재료명'].fillna('').str.contains('오징어').astype(int)
    df['contains_고등어'] = df['원재료명'].fillna('').str.contains('고등어').astype(int)
    df['contains_닭고기'] = df['원재료명'].fillna('').str.contains('닭고기').astype(int)
    df['contains_쇠고기'] = df['원재료명'].fillna('').str.contains('쇠고기').astype(int)
    df['contains_복숭아'] = df['원재료명'].fillna('').str.contains('복숭아').astype(int)
    df['contains_잣'] = df['원재료명'].fillna('').str.contains('잣').astype(int)
    df['contains_땅콩'] = df['원재료명'].fillna('').str.contains('땅콩').astype(int)
    df['contains_돼지고기'] = df['원재료명'].fillna('').str.contains('돼지고기').astype(int)
    df['contains_아황산류'] = df['원재료명'].fillna('').str.contains('아황산류').astype(int)
    df['contains_알류'] = df['원재료명'].fillna('').str.contains('알류').astype(int)
    return df[['user_age', 'user_gender', 'is_pregnant',
                   'contains_우유', 'contains_대두', 'contains_밀', 'contains_호두','contains_메밀','contains_새우','contains_조개류','contains_토마토','contains_딸기', 'contains_게', 'contains_오징어', 'contains_고등어', 'contains_닭고기', 'contains_쇠고기', 'contains_복숭아','contains_잣', 'contains_땅콩', 'contains_돼지고기', 'contains_아황산류','contains_알류']]
# 4. 메인 추천 함수
def recommend_xg(user_id, keyword, xgb_model_path='xgb_model.model', topk=5):
    # 사용자 선택
    if user_id not in user_df['user_id'].values:
        return f"❌ 사용자 ID '{user_id}'를 찾을 수 없습니다."
    user = user_df[user_df['user_id'] == user_id].iloc[0]

    # 입력 상품 검색
    matches = product_df[product_df['품명'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"❌ '{keyword}' 키워드를 포함한 상품이 없습니다."
    base_product = matches.iloc[0]
    base_category = base_product['category']

    # 같은 카테고리 내 유사 제품 추출 (입력 상품 제외)
    candidates = product_df[(product_df['category'] == base_category) &
                            (product_df['품명'] != base_product['품명'])].copy()

    # 적합한 제품만 필터링 (알레르기 + 임신 고려)
    candidates = candidates[candidates.apply(lambda row: is_product_suitable(user, row), axis=1)]

    # 특징 생성 + 예측
    X = prepare_features(user, candidates)
    dmatrix = xgb.DMatrix(X)

    # 모델 로드 및 예측
    booster = xgb.Booster()
    booster.load_model('xgb_model.model')
    preds = booster.predict(dmatrix)

    candidates['xgb_score'] = preds
    top_items = candidates.sort_values(by='xgb_score', ascending=False).head(topk)

    return top_items[['품명', 'xgb_score']]

def xgb_recommendation(result_df, user_id, topk=5, detailed=False):
    print(f"👤 {user_id}님이 선택하신 상품과(와) 유사한 추천 상품 Top {topk}:")
    print("=" * 50)

    if isinstance(result_df, str):  # 에러 메시지 반환된 경우
        print(result_df)
        return

    if detailed:
        for i, row in result_df.head(topk).iterrows():
            print(f"{i+1}. {row['품명']}")
            print(f"   - XGBoost 점수 : {row['xgb_score']:.4f}")
            print("-" * 40)
    else:
        for i, name in enumerate(result_df['품명'].head(topk), start=1):
            print(f"{i}. {name}")

# 예시 실행
result = recommend_xg('U002', '감자깡', topk=5)
xgb_recommendation(result, user_id='U002', topk=5, detailed=True)   # 점수 포함

xgb_recommendation(result, user_id='U002', topk=5, detailed=False)  # 품명만 출력

"""↑ XGBoost를 이용한 추천 알고리즘 (사용자 상호작용 반영X)

↓ XGBoost + LightFM
"""

!pip install lightfm
from lightfm import LightFM
from lightfm.data import Dataset
import pickle

# 1. 상호작용 데이터 로드
interaction_df = pd.read_csv('초기_상호작용_랜덤변경.csv')  # 파일명에 공백 있음 주의

# 2. 고유 유저/아이템 리스트 수집
user_list = interaction_df['user_id'].unique().tolist()
item_list = interaction_df['item_id'].unique().tolist()

# 3. Dataset 생성 및 fit
dataset = Dataset()
dataset.fit(users=user_list, items=item_list)

# 4. 상호작용 매트릭스 생성
(interactions, weights) = dataset.build_interactions([
    (row['user_id'], row['item_id'], row['liked']) for _, row in interaction_df.iterrows()
])

# 5. 모델 정의 및 학습
model = LightFM(loss='warp')  # WARP: 추천에 적합한 순위 기반 손실 함수
model.fit(interactions, epochs=20, num_threads=2)

# 6. 매핑 저장
user_id_map, user_feature_map, item_id_map, item_feature_map = dataset.mapping()
with open('lightfm_mapping.pkl', 'wb') as f:
    pickle.dump({'user_id_map': user_id_map, 'item_id_map': item_id_map}, f)

# 7. 모델 저장
with open('lightfm_model.pkl', 'wb') as f:
    pickle.dump(model, f)

print("✅ LightFM 학습 완료 및 저장 완료!")

def full_recommendation(user_id, keyword, user_df, product_df, xgb_model_path, lightfm_model_path, mapping_path, topk=5, detailed=False):
    import pickle
    import numpy as np
    import xgboost as xgb

    # Load LightFM 모델과 매핑
    with open(lightfm_model_path, 'rb') as f:
        lightfm_model = pickle.load(f)
    with open(mapping_path, 'rb') as f:
        mapping = pickle.load(f)
        user_id_map = mapping['user_id_map']
        item_id_map = mapping['item_id_map']

    # 사용자 정보 가져오기
    if user_id not in user_df['user_id'].values:
        return f"❌ 사용자 ID '{user_id}' 없음"
    user = user_df[user_df['user_id'] == user_id].iloc[0]

    # 입력 품명 검색 → 같은 카테고리 후보 추출
    matches = product_df[product_df['품명'].str.contains(keyword, case=False, na=False)]
    if matches.empty:
        return f"❌ '{keyword}' 키워드에 해당하는 상품 없음"
    base_product = matches.iloc[0]
    base_category = base_product['category']

    candidates = product_df[(product_df['category'] == base_category) &
                            (product_df['품명'] != base_product['품명'])].copy()

    # 필터링 (알레르기, 임신)
    candidates = candidates[candidates.apply(lambda row: is_product_suitable(user, row), axis=1)]

    # XGBoost 특징 생성 및 예측
    X = prepare_features(user, candidates)
    dmatrix = xgb.DMatrix(X)
    booster = xgb.Booster()
    booster.load_model('xgb_model.model')
    preds = booster.predict(dmatrix)
    candidates['xgb_score'] = preds

    # LightFM 점수 계산
    user_idx = user_id_map.get(user_id)
    product_names = candidates['품명'].tolist()
    item_indices = [item_id_map.get(name, -1) for name in product_names]
    scores = np.zeros(len(product_names))
    valid_idx = [i for i, idx in enumerate(item_indices) if idx >= 0]

    if user_idx is not None and valid_idx:
        preds = lightfm_model.predict(user_ids=user_idx, item_ids=[item_indices[i] for i in valid_idx])
        for i, score in zip(valid_idx, preds):
            scores[i] = score

    candidates['lightfm_score'] = scores
    candidates['final_score'] = 0.5 * candidates['xgb_score'] + 0.5 * candidates['lightfm_score']
    result = candidates.sort_values(by='final_score', ascending=False).reset_index(drop=True)

        # 🔽 출력 분기
    print(f"👤 {user_id}님이 선택하신 상품과(와) 유사한 추천 상품 Top {topk}:")
    print("=" * 50)
    for i, row in result.head(topk).iterrows():
        print(f"{i+1}. {row['품명']}")
        if detailed:
            print(f"   - XGBoost 점수 : {row['xgb_score']:.4f}")
            print(f"   - LightFM 점수 : {row['lightfm_score']:.4f}")
            print(f"   - 최종 추천 점수: {row['final_score']:.4f}")
            print("-" * 40)

full_recommendation("U002", "감자깡", user_df, product_df,'xgb_model.model', 'lightfm_model.pkl', 'lightfm_mapping.pkl', topk=5, detailed=True)

full_recommendation("U002", "감자깡", user_df, product_df,'xgb_model.model', 'lightfm_model.pkl', 'lightfm_mapping.pkl', topk=5, detailed = False)
